/*******************************************************
 * HS — Precificação / Comparador / Coleções
 * - Banco: uma linha por (REF, COLEÇÃO, PREÇO)
 * - Rotas GET: listCollections, searchReference, compareCollections, matrix
 * - Rotas POST: addCollection, exportCurrentPrices
 *******************************************************/

const SPREADSHEET_ID = "1v9GBXW-gqfU9Jx1MRkJQLkX8y8jJVbdhtlRM3Mh7dXM";
const SHEET_NAME     = "atualizada 11.04";

// Export "Leonardo"
const EXPORT_SHEET_ID  = "1T2_9rYF5DDfLuvS4H96UmEwxZeBgcWNaw3Hm9W2SEPE";
const EXPORT_TAB_NAME  = "Leonardo";
const EXPORT_PASSWORD  = "1234"; // <<<<< TROQUE AQUI

// Ordem das estações (VOCÊ confirmou que é: VERÃO, ALTO VERÃO, OUTONO, INVERNO)
const SEASON_ORDER = {
  "VERAO": 1, "VERÃO": 1,
  "ALTO VERAO": 2, "ALTO VERÃO": 2,
  "OUTONO": 3,
  "INVERNO": 4
};

// Cache (para ficar “instantâneo” no site)
const CACHE_KEY = "HS_PRECOS_CACHE_V2";
const CACHE_TTL = 60; // segundos (1 min já ajuda muito)

function doGet(e) {
  try {
    const action = e?.parameter?.action || "";
    const db = loadDb_(); // carrega + indexa + cache

    if (action === "listCollections") {
      return jsonOut_(db.collectionsSorted);
    }

    if (action === "searchReference") {
      const ref = normRef_(e.parameter.ref);
      const items = db.rowsByRef.get(ref) || [];
      const valid = items.filter(x => x.preco != null && x.preco > 0);

      if (!valid.length) return jsonOut_({ items: [] });

      // maior preço histórico
      let max = -Infinity;
      valid.forEach(v => { if (v.preco > max) max = v.preco; });
      const maxCols = valid.filter(v => v.preco === max).map(v => v.colecao);

      // "atual" = última coleção (pela ordenação)
      const lastItem = valid.slice().sort((a,b)=> a.key - b.key).pop();
      const atual = lastItem ? { colecao: lastItem.colecao, preco: lastItem.preco } : null;

      // lista por coleção (ordenada)
      const out = valid.slice().sort((a,b)=> a.key - b.key).map(v => ({ coll: v.colecao, price: v.preco }));

      return jsonOut_({
        items: out,
        max,
        maxCollections: sortCollections_(maxCols),
        atual
      });
    }

    if (action === "compareCollections") {
      const a = (e.parameter.a || "").trim();
      const b = (e.parameter.b || "").trim();
      if (!a || !b) return jsonOut_([]);

      const keyA = collectionKey_(a);
      const keyB = collectionKey_(b);

      // mapa ref -> preço na coleção A/B (rápido)
      const mapA = db.priceByRefColl.get(a) || new Map();
      const mapB = db.priceByRefColl.get(b) || new Map();

      const refs = db.allRefs;
      const list = refs.map(ref => {
        const va = mapA.has(ref) ? mapA.get(ref) : null;
        const vb = mapB.has(ref) ? mapB.get(ref) : null;

        const delta = (va!=null && vb!=null) ? round2_(vb - va) : null;
        const alterou = (delta != null && delta !== 0);

        let direcao = "SEM DADO";
        if (va!=null && vb!=null) {
          if (vb > va) direcao = "SUBIU";
          else if (vb < va) direcao = "DESCEU";
          else direcao = "IGUAL";
        }

        return {
          referencia: ref,
          precoA: va,
          precoB: vb,
          delta,
          alterou,
          direcao,
          keyA,
          keyB
        };
      });

      return jsonOut_(list);
    }

    if (action === "matrix") {
      const limit = Math.max(1, parseInt(e.parameter.limit || db.allRefs.length, 10) || db.allRefs.length);

      const refs = db.allRefs.slice(0, limit);
      const colls = db.collectionsSorted;

      // monta rows com lookup O(1)
      const rows = refs.map(ref => {
        const line = [ref];
        colls.forEach(c => {
          const m = db.priceByRefColl.get(c);
          const v = m ? m.get(ref) : null;
          line.push(v == null ? null : v);
        });
        return line;
      });

      return jsonOut_({ header: ["REF"].concat(colls), rows });
    }

    return jsonOut_({ erro: "Ação inválida: " + action });

  } catch (err) {
    return jsonOut_({ erro: err.message });
  }
}

function doPost(e) {
  try {
    const payload = JSON.parse(e.postData.contents || "{}");
    const action = (payload.action || "").trim();

    if (action === "addCollection") {
      // payload: {action:"addCollection", name:"OUTONO 25 REM", items:[{ref,price}]}
      const name = String(payload.name || "").trim();
      const items = payload.items || [];
      if (!name) throw new Error("Nome da coleção vazio.");
      if (!Array.isArray(items) || !items.length) throw new Error("Lista de itens vazia.");

      const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
      const sh = ss.getSheetByName(SHEET_NAME);
      if (!sh) throw new Error("Aba '" + SHEET_NAME + "' não encontrada.");

      const data = sh.getDataRange().getValues();
      const headers = (data[0] || []).map(h => String(h).trim().toUpperCase());

      const idxRef = headers.indexOf("REF");
      const idxPreco = headers.indexOf("PREÇO");
      const idxCol = headers.indexOf("COLEÇÃO");
      if (idxRef === -1 || idxPreco === -1 || idxCol === -1) {
        throw new Error("Cabeçalhos obrigatórios não encontrados: REF, PREÇO, COLEÇÃO");
      }

      const out = [];
      items.forEach(it => {
        const ref = normRef_(it.ref);
        const preco = parsePrice_(it.price);
        if (!ref) return;
        if (preco == null) return;
        out.push([ref, preco, name]);
      });

      if (!out.length) throw new Error("Nenhum item válido após validação.");

      // append (não mexe em linhas antigas)
      const startRow = sh.getLastRow() + 1;
      sh.getRange(startRow, 1, out.length, 3).setValues(out);

      // limpa cache para refletir instantâneo
      CacheService.getScriptCache().remove(CACHE_KEY);

      return jsonOut_({ status: "ok", inserted: out.length, colecao: name });
    }

    if (action === "exportCurrentPrices") {
      // payload: {action:"exportCurrentPrices", password:"...", baseCollection:"OUTONO 25" (opcional)}
      const pass = String(payload.password || "");
      if (pass !== EXPORT_PASSWORD) {
        return jsonOut_({ status:"erro", erro:"Senha inválida." });
      }

      const baseCollection = String(payload.baseCollection || "").trim(); // se vazio, usa "última"
      const db = loadDb_();

      // define "cutoff"
      const cutoffKey = baseCollection ? collectionKey_(baseCollection) : (db.lastCollectionKey || 0);

      // Para cada REF: pegar último preço conhecido ATÉ cutoffKey
      const out = [];
      db.allRefs.forEach(ref => {
        const items = db.rowsByRef.get(ref) || [];
        // pega o último <= cutoff
        let best = null;
        for (let i=0;i<items.length;i++){
          const it = items[i];
          if (it.preco == null) continue;
          if (it.key <= cutoffKey) {
            if (!best || it.key > best.key) best = it;
          }
        }
        if (best) {
          out.push([ref, best.preco, "COLEÇÃO ATUAL"]);
        }
      });

      // grava na planilha Leonardo
      const ss = SpreadsheetApp.openById(EXPORT_SHEET_ID);
      const sh = ss.getSheetByName(EXPORT_TAB_NAME);
      if (!sh) throw new Error("Aba '" + EXPORT_TAB_NAME + "' não encontrada na planilha de export.");

      // sobrescreve A:C (conforme você decidiu que não precisa histórico)
      sh.getRange("A:C").clearContent();
      if (out.length) {
        sh.getRange(1, 1, out.length, 3).setValues(out);
      }

      return jsonOut_({ status:"ok", exported: out.length, cutoff: baseCollection || "ÚLTIMA" });
    }

    return jsonOut_({ status:"erro", erro:"Ação POST inválida: " + action });

  } catch (err) {
    return jsonOut_({ status:"erro", erro: err.message });
  }
}

/* =========================
   DB / CACHE / INDEX
========================= */
function loadDb_(){
  const cache = CacheService.getScriptCache();
  const cached = cache.get(CACHE_KEY);
  if (cached) {
    return JSON.parse(cached);
  }

  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sh = ss.getSheetByName(SHEET_NAME);
  if (!sh) throw new Error("Aba '" + SHEET_NAME + "' não encontrada.");

  const values = sh.getDataRange().getValues();
  if (!values || values.length < 2) {
    const empty = { collectionsSorted:[], rowsByRef: new Map(), priceByRefColl: new Map(), allRefs:[], lastCollectionKey:0 };
    cache.put(CACHE_KEY, JSON.stringify(serializeDb_(empty)), CACHE_TTL);
    return deserializeDb_(JSON.parse(cache.get(CACHE_KEY)));
  }

  const headers = values[0].map(h => String(h).trim().toUpperCase());
  const idxRef = headers.indexOf("REF");
  const idxPreco = headers.indexOf("PREÇO");
  const idxCol = headers.indexOf("COLEÇÃO");
  if (idxRef === -1 || idxPreco === -1 || idxCol === -1) {
    throw new Error("Cabeçalhos obrigatórios não encontrados: REF, PREÇO, COLEÇÃO");
  }

  const rowsByRef = new Map();
  const priceByRefColl = new Map();
  const collsSet = new Set();
  const refsSet = new Set();

  let lastCollectionKey = 0;

  for (let i=1;i<values.length;i++){
    const r = values[i];
    const ref = normRef_(r[idxRef]);
    const preco = parsePrice_(r[idxPreco]);
    const colecao = String(r[idxCol] || "").trim();
    if (!ref || !colecao) continue;

    const key = collectionKey_(colecao);
    if (key > lastCollectionKey) lastCollectionKey = key;

    collsSet.add(colecao);
    refsSet.add(ref);

    const obj = { ref, preco, colecao, key };

    if (!rowsByRef.has(ref)) rowsByRef.set(ref, []);
    rowsByRef.get(ref).push(obj);

    if (!priceByRefColl.has(colecao)) priceByRefColl.set(colecao, new Map());
    // se repetiu a mesma ref na mesma coleção, mantém o último (ou o maior, se preferir)
    priceByRefColl.get(colecao).set(ref, (preco == null ? null : round2_(preco)));
  }

  // ordena coleções
  const collectionsSorted = sortCollections_(Array.from(collsSet));
  // ordena itens por ref (para export ficar rápido)
  rowsByRef.forEach(arr => arr.sort((a,b)=> a.key - b.key));

  const db = {
    collectionsSorted,
    allRefs: Array.from(refsSet).sort(),
    lastCollectionKey,
    rowsByRef,
    priceByRefColl
  };

  // cache precisa serializar Map
  cache.put(CACHE_KEY, JSON.stringify(serializeDb_(db)), CACHE_TTL);
  return deserializeDb_(JSON.parse(cache.get(CACHE_KEY)));
}

function serializeDb_(db){
  return {
    collectionsSorted: db.collectionsSorted,
    allRefs: db.allRefs,
    lastCollectionKey: db.lastCollectionKey,
    rowsByRef: Array.from(db.rowsByRef.entries()),
    priceByRefColl: Array.from(db.priceByRefColl.entries()).map(([coll, mp]) => [coll, Array.from(mp.entries())])
  };
}
function deserializeDb_(raw){
  const rowsByRef = new Map(raw.rowsByRef || []);
  // rowsByRef vem como arrays de objetos ok
  const priceByRefColl = new Map();
  (raw.priceByRefColl || []).forEach(([coll, entries])=>{
    priceByRefColl.set(coll, new Map(entries));
  });
  return {
    collectionsSorted: raw.collectionsSorted || [],
    allRefs: raw.allRefs || [],
    lastCollectionKey: raw.lastCollectionKey || 0,
    rowsByRef,
    priceByRefColl
  };
}

/* =========================
   COLEÇÕES / PARSE
========================= */
function collectionKey_(name){
  const info = parseCollName_(name);
  // chave crescente: AAAA * 1000 + seasonOrder*100 + remIndex
  return (info.ano * 1000) + (info.ordem * 100) + (info.remIndex || 0);
}

function parseCollName_(name){
  const raw = String(name || "").trim();
  const upper = raw
    .toUpperCase()
    .replace(/\s+/g," ")
    .replace(/\s*-\s*/g," ");

  // ano (pega 20xx ou último 2 dígitos)
  let ano = 9999;
  const m4 = upper.match(/20\d{2}/g);
  if (m4 && m4.length) ano = parseInt(m4[m4.length-1], 10);
  else {
    const m2 = upper.match(/(\d{2})(?!.*\d)/);
    if (m2) ano = 2000 + parseInt(m2[1], 10);
  }

  // estação
  let season = "EXTRA";
  if (upper.includes("INVERNO")) season = "INVERNO";
  else if (upper.includes("OUTONO")) season = "OUTONO";
  else if (upper.includes("ALTO") && (upper.includes("VERAO") || upper.includes("VERÃO"))) season = "ALTO VERÃO";
  else if (upper.includes("VERAO") || upper.includes("VERÃO")) season = "VERÃO";

  const ordem = SEASON_ORDER[season.toUpperCase().replace("Ã","A")] || 99;

  // REM: pode ter várias “remarcações”
  // exemplos aceitos: "REM", "REM 2", "REM2"
  let remIndex = 0;
  const rem = upper.match(/\bREM\s*([0-9]+)?\b/);
  if (rem) remIndex = rem[1] ? parseInt(rem[1],10) : 1;

  return { raw, ano, season, ordem, remIndex };
}

function sortCollections_(colls){
  const uniq = Array.from(new Set((colls||[]).filter(Boolean)));
  return uniq
    .map(c => ({ c, key: collectionKey_(c) }))
    .sort((a,b)=> a.key - b.key || a.c.localeCompare(b.c))
    .map(x => x.c);
}

/* =========================
   HELPERS
========================= */
function normRef_(v){
  return String(v || "").trim().toUpperCase();
}

function parsePrice_(v){
  if (v === "" || v == null) return null;
  // aceita "89,99", "89.99", "R$ 89,99"
  const s = String(v).replace(/[R$\s]/g,"").replace(/\./g,"").replace(",",".");
  const n = parseFloat(s);
  if (isNaN(n)) return null;
  return round2_(n);
}

function round2_(n){
  return Math.round((Number(n) + Number.EPSILON) * 100) / 100;
}

function jsonOut_(obj){
  return ContentService
    .createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}
